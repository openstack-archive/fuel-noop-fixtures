Typical use cases
=================

Let's discuss the most common use cases of the Noop test framework and how it
can be used.

Running all tests using multiple processes
------------------------------------------

Running **tests/noop/noop_tests.sh** without any options will try to execute
all the spec tasks one by one. The list of the spec tasks will be generated by
combining all the possible combinations of specs, hiera files and facts files
that are allowed for this spec. Adding **-p** options allows you to review the
list of tasks that will be run without actually running them.

Running tasks one by one will be a very time consuming process, so you should
try to use multi-process run instead by providing the **-j** options with a
number of processes that can be started simultaneously. In this mode you
will not see the output of every RSpec process, but you will be able to get
the combined result report of all test runs at the end of the process.

You can also monitor the progress of tasks by using the debug option **-d**.
It will show you which tasks are starting and finishing and what shell commands
and environment variables are used to run them.::

  tests/noop/noop_tests.sh -j 24 -d

Will run all the spec task with debug output and keeping no more then 24
child processes all the time.::

  tests/noop/noop_tests.sh -p

Will output the list of tasks that is going to be run together with the facts
and yaml files used.

There is also the **run_all.sh** shortcut script for this action.

Running only a subset of tasks
------------------------------

In many cases you would want to run only a subset of tasks, up to only one task.
You can use filters to do so. By providing the **-s**, **-y** and **-f** will
allow you to set one or more specs, yams and facts that you want to use. The
list of tasks will be build by filtering out everything else that you have
not specified. Don't forget that you can use the **-p** option to review the
list of tasks before actually running them.

List options **-Y**, **-F**, **-S** and **-T** can be used to view the list of
all hiera yaml files, facts files, spec files and task files respectively.
These lists are very helpful for finding out correct values for the filter
options you want to use. Note, that using filter and list options together will
allow you to see the filtered lists.::

  tests/noop/noop_tests.sh -Y

Will list all available hiera yaml files.::

  tests/noop/noop_tests.sh -y neut_vlan.compute.ssl.yaml -p

Will show you which task are going to run with this yaml file.::

 tests/noop/noop_tests.sh -y neut_vlan.compute.ssl -s firewall/firewall -f ubuntu

Will run the *firewall/firewall* spec test with the provided yaml and facts
file, but it will only work if this combination is allowed for this spec.
Note, that you can either provide **.yaml**, **_spec.rb**, **.pp** extensions
for yaml and spec files, or you can omit them and they will be found out on
their own.::

  tests/noop/noop_tests.sh -y neut_vlan.compute.ssl,neut_vlan.compute.nossl -s firewall/firewall,netconfig/netconfig -p

Filters can use used with a list of elements like this.

Recreating globals yaml files
-----------------------------

All globals files should already be precreated and commited to the fixtures
repository and there is no need for you to create them again in the most cases.
But, if you have made some changes to the existing yaml files or have
added a new one, you should create the globals yamls again.

You can do it by running *tests/noop/noop_tests.sh* with **-g** option.
It will set filters to run only the globals tasks as well as enabling the
option to save the generated yaml files. Using **-j** option will make the
process much faster.

There is also the **run_globals.sh** shortcut script for this action.

Spec file annotations
---------------------

The framework builds the list of tasks to run by combining all allowed facts
and yaml files for each spec file and creating a task for every combination.

By default, the list of yaml files, allowed for each spec will be determined
by the intersection of node roles the spec should be run on (obtained from the
*tasks.yaml* files used by the Nailgun to compile the deployment graph) and the
hiera file roles (obtained from the hiera files themselves). The facts file
will default to **ubuntu** value.

In most cases it would be better to manually specify the hiera files and,
possibly, the facts files for your spec file, because running a task for every
hiera file with the same roles would be redundant. On the other hand, if you
know which Hiera files can cause a different behaviour of your task, and you
want to test this behaviour in the different scenarios, you can explicitly
specify the list of yaml files and facts files you need.

The list of Hiera files can be set by using the **HIERA:** commented annotation
string followed by the list of hiera file names separated by the space
character.::

  # HIERA: neut_vlan.compute.ssl neut_vlan.compute.nossl

The list of facts files can be specified the same way using the **FACTS:**
annotation.::

  # FACTS: centos6 centos7

The list of task will contain this spec with all possible combinations of the
specified Hiera and facts files. If you need to enter only the precise list of
possible run combinations you can use the **RUN:** annotation.::

  # RUN: (hiera1) (facts1)
  # RUN: (hiera2) (facts2)

It can be specified many times an all entered combinations will be added to the
list.

The final annotation **DISABLE_SPEC** allows you to temporarily disable the
spec from being seen the framework. It can use useful if you want to turn off
a spec with run problems and fix them later without breaking the tests.::

  # DISABLE_SPEC

The spec file with this annotation will be completely ignored.

Using hiera and facts overrides
-------------------------------

In some cases you need a special set of facts values or the Hiera data for
your task. If this values are very specific and are not useful for other tasks
you can use override system instead of creating the new Hiera or facts yaml.

There are *override* folders inside the Hiera and facts folders. If you place
a yaml file with the specific name to this folder, it will be used during the
spec catalog compilation as the top level of Hiera's hierarchy. The values which
are specified there will be used before the values in other yaml files. Hash
values will be merged on the basic values and the matching key will be
rewritten. Facts yamls work the same way by rewriting the basic values by the
values specified in the override file.

Both yaml files should be named after the task name with path separator changed
to the dash character. For example, the **firewall/firewall** task will use
the override file name *firewall-firewall.yaml* and
**openstack-controller/keystone** task will use the file name
*openstack-controller-keystone.yaml* if these files are found in the
override folders.

Working with report files
-------------------------

When the task manager runs the tasks they leave report files anf the manager
can collect them to generate a combined test report seen at the end of the test
process. These files can be found in the reports folder and re in json format.

You can use **-r** and **-R** options to load the saved reports from the
previous run and display the report again, or to load reports and run the tasks
that have previously failed after you have tried to somehow fix them.

The task manager can also generate a test report in *jUnit XML* format using
the **-x** options. It will be saves to the **report.xml** file in the *reports*
folder of the fixtures repository. This file can be used by many tools to
visualize the tests results, notably by the Jenkins CI.

Catalog debugging
-----------------

There are several features that can be helpful during writing the initial spec
for a task or when you are debugging a spec failure. Running tasks with **-a**
options will show the report text about which files are being used in this task
run and what files are found in Hiera and facts hierarchies.

Using **-A** option will output the entire compiled catalog in the Puppet DSL
format. You can review its content and resource parameters to either find
out what resources and classes are there or to see what values the parameters
and properties actually have after all the catalog logic is processed. It's
very helpful when you are debugging a strange task behaviour or writing a spec
file.

Initial setup options
---------------------

The *tests/noop/noop_tests.sh* script will try to do some initial Ruby
environment setup but there are also **-b** and **-B** options to run the
environment setup using *bundle* and to run rspec processes using *bundle exec*
respectively.

You can also work with the external Puppet modules by using the **-l** and
**-L** options to either install the missing modules or to reset them to the
initial state.

Using external environment variables and custom paths
-----------------------------------------------------

There are a number of environment variables used by either the task manager or
by the specs themselves which can alter their behaviour and override the
default or calculated values.

Paths related:

- **SPEC_ROOT_DIR** Set the path to the root folder of the framework. Many
  other folders are found relative to this path.
- **SPEC_SPEC_DIR** The path to the folder with the spec files. You can change
  it but it should be at the *spec/hosts* from the root folder or the
  rpsec-puppet will break.
- **SPEC_MODULE_PATH** or **SPEC_MODULEPATH** Set the path to the modules
  library.
- **SPEC_TASK_DIR** Set the path to the task manifests folder.
- **SPEC_DEPLOYMENT_DIR** Set the path to the *deployment* directory. It's
  actually use only to find the scripts to udate and reset modules.
- **WORKSPACE** This variable is passed by the Jenkins jobs or will default to
  the *workspece* folder. Currently used only to store the Ruby gems installed
  by the *bundler* if *RVM* is not used.
- **SPEC_FACTS_DIR** The path to the folder with facts yaml files.
- **SPEC_HIERA_DIR** or **SPEC_YAML_DIR** The path to the folder with Hiera
  yaml files.

Spec related:

- **SPEC_FACTS_NAME** Set the name of the facts file that will be used by the
  spec process.
  It's set when the task is being run.
- **SPEC_HIERA_NAME** or **SPEC_ASTUTE_FILE_NAME** Set the name of the Hiera
  yaml file that will be used by the spec process.
  It's set when the task is being run.
- **SPEC_FILE_NAME** Set the spec/manifest file name for the spec process to
  test.
  It's set when the task is being run and even can override the internal value.
- **SPEC_BUNDLE_EXEC** Use *bundle exec* to run the *rspec* command by the
  task object.
- **SPEC_UPDATE_GLOBALS** Save the generated globals files instead of just
  checking that globals task's catalog is compiling without and error.
- **SPEC_CATALOG_SHOW** Ask the spec to output the catalog contents.
- **SPEC_SHOW_STATUS** Ask the spec to output the status text.

Debug related:

- **SPEC_TASK_CONSOLE** Run the pry console in the manager process.
- **SPEC_RSPEC_CONSOLE** Run the pry console in the RSpec process.
- **SPEC_PUPPET_DEBUG** Enable debug output of the Puppet's catalog compilation.
  This variable is also used by many other rspec suites of the Mirantis
  Puppet modules outside of the Noop tests framework to output the
  additional debug information.
- **SPEC_TASK_DEBUG** Enable the debug output of the task and manager objects.
- **SPEC_DEBUG_LOG** This variable can the the debug log destination file.

Many of this variables can be set by the Noop manager CLI options, or you can
always export them externally.
